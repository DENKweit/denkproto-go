// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prediction.proto

package prediction

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on UInt8Map with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UInt8Map) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UInt8Map with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UInt8MapMultiError, or nil
// if none found.
func (m *UInt8Map) ValidateAll() error {
	return m.validate(true)
}

func (m *UInt8Map) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for Data

	if len(errors) > 0 {
		return UInt8MapMultiError(errors)
	}

	return nil
}

// UInt8MapMultiError is an error wrapping multiple validation errors returned
// by UInt8Map.ValidateAll() if the designated constraints aren't met.
type UInt8MapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UInt8MapMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UInt8MapMultiError) AllErrors() []error { return m }

// UInt8MapValidationError is the validation error returned by
// UInt8Map.Validate if the designated constraints aren't met.
type UInt8MapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UInt8MapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UInt8MapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UInt8MapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UInt8MapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UInt8MapValidationError) ErrorName() string { return "UInt8MapValidationError" }

// Error satisfies the builtin error interface
func (e UInt8MapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUInt8Map.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UInt8MapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UInt8MapValidationError{}

// Validate checks the field values on ClassificationPrediction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClassificationPrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClassificationPrediction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClassificationPredictionMultiError, or nil if none found.
func (m *ClassificationPrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *ClassificationPrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelId

	// no validation rules for Probability

	if all {
		switch v := interface{}(m.GetInterpretationMap()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClassificationPredictionValidationError{
					field:  "InterpretationMap",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClassificationPredictionValidationError{
					field:  "InterpretationMap",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterpretationMap()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClassificationPredictionValidationError{
				field:  "InterpretationMap",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClassificationPredictionMultiError(errors)
	}

	return nil
}

// ClassificationPredictionMultiError is an error wrapping multiple validation
// errors returned by ClassificationPrediction.ValidateAll() if the designated
// constraints aren't met.
type ClassificationPredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClassificationPredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClassificationPredictionMultiError) AllErrors() []error { return m }

// ClassificationPredictionValidationError is the validation error returned by
// ClassificationPrediction.Validate if the designated constraints aren't met.
type ClassificationPredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClassificationPredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClassificationPredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClassificationPredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClassificationPredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClassificationPredictionValidationError) ErrorName() string {
	return "ClassificationPredictionValidationError"
}

// Error satisfies the builtin error interface
func (e ClassificationPredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClassificationPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClassificationPredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClassificationPredictionValidationError{}

// Validate checks the field values on ObjectDetectionPrediction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectDetectionPrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectDetectionPrediction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectDetectionPredictionMultiError, or nil if none found.
func (m *ObjectDetectionPrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectDetectionPrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelId

	if all {
		switch v := interface{}(m.GetBoundingBox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectDetectionPredictionValidationError{
					field:  "BoundingBox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectDetectionPredictionValidationError{
					field:  "BoundingBox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBoundingBox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectDetectionPredictionValidationError{
				field:  "BoundingBox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Probability

	if len(errors) > 0 {
		return ObjectDetectionPredictionMultiError(errors)
	}

	return nil
}

// ObjectDetectionPredictionMultiError is an error wrapping multiple validation
// errors returned by ObjectDetectionPrediction.ValidateAll() if the
// designated constraints aren't met.
type ObjectDetectionPredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectDetectionPredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectDetectionPredictionMultiError) AllErrors() []error { return m }

// ObjectDetectionPredictionValidationError is the validation error returned by
// ObjectDetectionPrediction.Validate if the designated constraints aren't met.
type ObjectDetectionPredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectDetectionPredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectDetectionPredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectDetectionPredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectDetectionPredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectDetectionPredictionValidationError) ErrorName() string {
	return "ObjectDetectionPredictionValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectDetectionPredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectDetectionPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectDetectionPredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectDetectionPredictionValidationError{}

// Validate checks the field values on InstanceSegmentationPrediction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceSegmentationPrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceSegmentationPrediction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InstanceSegmentationPredictionMultiError, or nil if none found.
func (m *InstanceSegmentationPrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceSegmentationPrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelId

	if all {
		switch v := interface{}(m.GetMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceSegmentationPredictionValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceSegmentationPredictionValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceSegmentationPredictionValidationError{
				field:  "Mask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Probability

	if len(errors) > 0 {
		return InstanceSegmentationPredictionMultiError(errors)
	}

	return nil
}

// InstanceSegmentationPredictionMultiError is an error wrapping multiple
// validation errors returned by InstanceSegmentationPrediction.ValidateAll()
// if the designated constraints aren't met.
type InstanceSegmentationPredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceSegmentationPredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceSegmentationPredictionMultiError) AllErrors() []error { return m }

// InstanceSegmentationPredictionValidationError is the validation error
// returned by InstanceSegmentationPrediction.Validate if the designated
// constraints aren't met.
type InstanceSegmentationPredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceSegmentationPredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceSegmentationPredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceSegmentationPredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceSegmentationPredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceSegmentationPredictionValidationError) ErrorName() string {
	return "InstanceSegmentationPredictionValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceSegmentationPredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceSegmentationPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceSegmentationPredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceSegmentationPredictionValidationError{}

// Validate checks the field values on CharacterPrediction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterPrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterPrediction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterPredictionMultiError, or nil if none found.
func (m *CharacterPrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterPrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Character

	// no validation rules for Probability

	if len(errors) > 0 {
		return CharacterPredictionMultiError(errors)
	}

	return nil
}

// CharacterPredictionMultiError is an error wrapping multiple validation
// errors returned by CharacterPrediction.ValidateAll() if the designated
// constraints aren't met.
type CharacterPredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterPredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterPredictionMultiError) AllErrors() []error { return m }

// CharacterPredictionValidationError is the validation error returned by
// CharacterPrediction.Validate if the designated constraints aren't met.
type CharacterPredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterPredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterPredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterPredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterPredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterPredictionValidationError) ErrorName() string {
	return "CharacterPredictionValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterPredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterPredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterPredictionValidationError{}

// Validate checks the field values on OcrPrediction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OcrPrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OcrPrediction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OcrPredictionMultiError, or
// nil if none found.
func (m *OcrPrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *OcrPrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelId

	for idx, item := range m.GetCharacterPredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OcrPredictionValidationError{
						field:  fmt.Sprintf("CharacterPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OcrPredictionValidationError{
						field:  fmt.Sprintf("CharacterPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OcrPredictionValidationError{
					field:  fmt.Sprintf("CharacterPredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.GeometryData.(type) {
	case *OcrPrediction_BoundingBox:
		if v == nil {
			err := OcrPredictionValidationError{
				field:  "GeometryData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBoundingBox()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OcrPredictionValidationError{
						field:  "BoundingBox",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OcrPredictionValidationError{
						field:  "BoundingBox",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBoundingBox()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OcrPredictionValidationError{
					field:  "BoundingBox",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OcrPrediction_Polygon:
		if v == nil {
			err := OcrPredictionValidationError{
				field:  "GeometryData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPolygon()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OcrPredictionValidationError{
						field:  "Polygon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OcrPredictionValidationError{
						field:  "Polygon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPolygon()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OcrPredictionValidationError{
					field:  "Polygon",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Text != nil {
		// no validation rules for Text
	}

	if len(errors) > 0 {
		return OcrPredictionMultiError(errors)
	}

	return nil
}

// OcrPredictionMultiError is an error wrapping multiple validation errors
// returned by OcrPrediction.ValidateAll() if the designated constraints
// aren't met.
type OcrPredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OcrPredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OcrPredictionMultiError) AllErrors() []error { return m }

// OcrPredictionValidationError is the validation error returned by
// OcrPrediction.Validate if the designated constraints aren't met.
type OcrPredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OcrPredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OcrPredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OcrPredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OcrPredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OcrPredictionValidationError) ErrorName() string { return "OcrPredictionValidationError" }

// Error satisfies the builtin error interface
func (e OcrPredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOcrPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OcrPredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OcrPredictionValidationError{}

// Validate checks the field values on BarcodePrediction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BarcodePrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BarcodePrediction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BarcodePredictionMultiError, or nil if none found.
func (m *BarcodePrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *BarcodePrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelId

	// no validation rules for Data

	for idx, item := range m.GetPoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BarcodePredictionValidationError{
						field:  fmt.Sprintf("Points[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BarcodePredictionValidationError{
						field:  fmt.Sprintf("Points[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BarcodePredictionValidationError{
					field:  fmt.Sprintf("Points[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BarcodePredictionMultiError(errors)
	}

	return nil
}

// BarcodePredictionMultiError is an error wrapping multiple validation errors
// returned by BarcodePrediction.ValidateAll() if the designated constraints
// aren't met.
type BarcodePredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BarcodePredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BarcodePredictionMultiError) AllErrors() []error { return m }

// BarcodePredictionValidationError is the validation error returned by
// BarcodePrediction.Validate if the designated constraints aren't met.
type BarcodePredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BarcodePredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BarcodePredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BarcodePredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BarcodePredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BarcodePredictionValidationError) ErrorName() string {
	return "BarcodePredictionValidationError"
}

// Error satisfies the builtin error interface
func (e BarcodePredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBarcodePrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BarcodePredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BarcodePredictionValidationError{}

// Validate checks the field values on AnomalyPrediction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AnomalyPrediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnomalyPrediction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnomalyPredictionMultiError, or nil if none found.
func (m *AnomalyPrediction) ValidateAll() error {
	return m.validate(true)
}

func (m *AnomalyPrediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAnomalyMap()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnomalyPredictionValidationError{
					field:  "AnomalyMap",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnomalyPredictionValidationError{
					field:  "AnomalyMap",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnomalyMap()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnomalyPredictionValidationError{
				field:  "AnomalyMap",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AnomalyPredictionMultiError(errors)
	}

	return nil
}

// AnomalyPredictionMultiError is an error wrapping multiple validation errors
// returned by AnomalyPrediction.ValidateAll() if the designated constraints
// aren't met.
type AnomalyPredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnomalyPredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnomalyPredictionMultiError) AllErrors() []error { return m }

// AnomalyPredictionValidationError is the validation error returned by
// AnomalyPrediction.Validate if the designated constraints aren't met.
type AnomalyPredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnomalyPredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnomalyPredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnomalyPredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnomalyPredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnomalyPredictionValidationError) ErrorName() string {
	return "AnomalyPredictionValidationError"
}

// Error satisfies the builtin error interface
func (e AnomalyPredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnomalyPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnomalyPredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnomalyPredictionValidationError{}

// Validate checks the field values on Prediction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Prediction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Prediction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PredictionMultiError, or
// nil if none found.
func (m *Prediction) ValidateAll() error {
	return m.validate(true)
}

func (m *Prediction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Height

	// no validation rules for Width

	for idx, item := range m.GetClassificationPredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("ClassificationPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("ClassificationPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PredictionValidationError{
					field:  fmt.Sprintf("ClassificationPredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetObjectDetectionPredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("ObjectDetectionPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("ObjectDetectionPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PredictionValidationError{
					field:  fmt.Sprintf("ObjectDetectionPredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstanceSegmentationPredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("InstanceSegmentationPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("InstanceSegmentationPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PredictionValidationError{
					field:  fmt.Sprintf("InstanceSegmentationPredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOcrPredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("OcrPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("OcrPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PredictionValidationError{
					field:  fmt.Sprintf("OcrPredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBarcodePredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("BarcodePredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("BarcodePredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PredictionValidationError{
					field:  fmt.Sprintf("BarcodePredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnomalyPredictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("AnomalyPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PredictionValidationError{
						field:  fmt.Sprintf("AnomalyPredictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PredictionValidationError{
					field:  fmt.Sprintf("AnomalyPredictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PredictionMultiError(errors)
	}

	return nil
}

// PredictionMultiError is an error wrapping multiple validation errors
// returned by Prediction.ValidateAll() if the designated constraints aren't met.
type PredictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PredictionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PredictionMultiError) AllErrors() []error { return m }

// PredictionValidationError is the validation error returned by
// Prediction.Validate if the designated constraints aren't met.
type PredictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PredictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PredictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PredictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PredictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PredictionValidationError) ErrorName() string { return "PredictionValidationError" }

// Error satisfies the builtin error interface
func (e PredictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrediction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PredictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PredictionValidationError{}
