// Code generated by generate_go_code.go; DO NOT EDIT.
// Based on schema: ../inference_graph_recipe.schema.json

package inference_graph_recipe

import (
	"encoding/json"
	"fmt"
)

// AddNumbersNode corresponds to the JSON schema definition 'AddNumbersNode'.
// Node that adds two numbers. Base type for all nodes in the graph.
type AddNumbersNode struct {
	InputNumber1 string `json:"input_number_1"`
	InputNumber2 string `json:"input_number_2"`
	Name         string `json:"name"`
	NodeType     string `json:"node_type"`
	Output       string `json:"output"`
}

// isNode implements the Node interface.
func (s *AddNumbersNode) isNode() {}

// NewAddNumbersNode creates a new instance of AddNumbersNode
func NewAddNumbersNode(name string, inputnumber1 string, inputnumber2 string, output string) *AddNumbersNode {
	return &AddNumbersNode{
		Name:         name,
		InputNumber1: inputnumber1,
		InputNumber2: inputnumber2,
		Output:       output,
		NodeType:     "add_numbers",
	}
}

// BoundingBoxFilterNode corresponds to the JSON schema definition 'BoundingBoxFilterNode'.
// Node that filters bounding boxes based on a threshold. Base type for all nodes in the graph.
type BoundingBoxFilterNode struct {
	InputBoxes     string `json:"input_boxes"`
	InputThreshold string `json:"input_threshold"`
	Name           string `json:"name"`
	NodeType       string `json:"node_type"`
	OutputBatchMap string `json:"output_batch_map"`
	OutputBoxes    string `json:"output_boxes"`
}

// isNode implements the Node interface.
func (s *BoundingBoxFilterNode) isNode() {}

// NewBoundingBoxFilterNode creates a new instance of BoundingBoxFilterNode
func NewBoundingBoxFilterNode(name string, inputthreshold string, inputboxes string, outputboxes string, outputbatchmap string) *BoundingBoxFilterNode {
	return &BoundingBoxFilterNode{
		Name:           name,
		InputThreshold: inputthreshold,
		InputBoxes:     inputboxes,
		OutputBoxes:    outputboxes,
		OutputBatchMap: outputbatchmap,
		NodeType:       "bounding_box_filter",
	}
}

// ConstTensorFloat64Data corresponds to the JSON schema definition 'ConstTensorFloat64Data'.
// Constant tensor data of type float64. Base type for constant tensor data.
type ConstTensorFloat64Data struct {
	Data     []float64 `json:"data"`
	DataType string    `json:"data_type"`
}

// isConstTensorDataBase implements the ConstTensorDataBase interface.
func (s *ConstTensorFloat64Data) isConstTensorDataBase() {}

// NewConstTensorFloat64Data creates a new instance of ConstTensorFloat64Data
func NewConstTensorFloat64Data(data []float64) *ConstTensorFloat64Data {
	return &ConstTensorFloat64Data{
		Data:     data,
		DataType: "float64",
	}
}

// ConstTensorInt64Data corresponds to the JSON schema definition 'ConstTensorInt64Data'.
// Constant tensor data of type int64. Base type for constant tensor data.
type ConstTensorInt64Data struct {
	Data     []int64 `json:"data"`
	DataType string  `json:"data_type"`
}

// isConstTensorDataBase implements the ConstTensorDataBase interface.
func (s *ConstTensorInt64Data) isConstTensorDataBase() {}

// NewConstTensorInt64Data creates a new instance of ConstTensorInt64Data
func NewConstTensorInt64Data(data []int64) *ConstTensorInt64Data {
	return &ConstTensorInt64Data{
		Data:     data,
		DataType: "int64",
	}
}

// ConstTensorNode corresponds to the JSON schema definition 'ConstTensorNode'.
// Node representing a constant tensor. Base type for all nodes in the graph.
type ConstTensorNode struct {
	Data     ConstTensorDataBase `json:"data"`
	Name     string              `json:"name"`
	NodeType string              `json:"node_type"`
	Output   string              `json:"output"`
	Shape    []int64             `json:"shape"`
}

// isNode implements the Node interface.
func (s *ConstTensorNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ConstTensorNode to handle interface fields
func (s *ConstTensorNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ConstTensorNode

	intermediate := struct {
		Alias
		Data json.RawMessage `json:"data"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ConstTensorNode: %w", err)
	}

	// Copy the standard fields
	*s = ConstTensorNode(intermediate.Alias)

	// Unmarshal the Data field (ConstTensorDataBase interface)
	if len(intermediate.Data) > 0 {
		var item ConstTensorDataBase
		if err := UnmarshalJSONConstTensorDataBase(intermediate.Data, &item); err != nil {
			return fmt.Errorf("error unmarshaling Data: %w", err)
		}
		s.Data = item
	}

	return nil
}

// NewConstTensorNode creates a new instance of ConstTensorNode
func NewConstTensorNode(name string, output string, shape []int64) *ConstTensorNode {
	return &ConstTensorNode{
		Name:     name,
		Output:   output,
		Shape:    shape,
		NodeType: "const_tensor",
	}
}

// SetData sets the Data field for ConstTensorNode
func (s *ConstTensorNode) SetData(data ConstTensorDataBase) {
	s.Data = data
}

// ConstTensorUint64Data corresponds to the JSON schema definition 'ConstTensorUint64Data'.
// Constant tensor data of type uint64. Base type for constant tensor data.
type ConstTensorUint64Data struct {
	Data     []int64 `json:"data"`
	DataType string  `json:"data_type"`
}

// isConstTensorDataBase implements the ConstTensorDataBase interface.
func (s *ConstTensorUint64Data) isConstTensorDataBase() {}

// NewConstTensorUint64Data creates a new instance of ConstTensorUint64Data
func NewConstTensorUint64Data(data []int64) *ConstTensorUint64Data {
	return &ConstTensorUint64Data{
		Data:     data,
		DataType: "uint64",
	}
}

// GenerateNumberNode corresponds to the JSON schema definition 'GenerateNumberNode'.
// Node that generates a number within a range. Base type for all nodes in the graph.
type GenerateNumberNode struct {
	Max      int64  `json:"max"`
	Min      int64  `json:"min"`
	Name     string `json:"name"`
	NodeType string `json:"node_type"`
	Output   string `json:"output"`
}

// isNode implements the Node interface.
func (s *GenerateNumberNode) isNode() {}

// NewGenerateNumberNode creates a new instance of GenerateNumberNode
func NewGenerateNumberNode(name string, output string, min int64, max int64) *GenerateNumberNode {
	return &GenerateNumberNode{
		Name:     name,
		Output:   output,
		Min:      min,
		Max:      max,
		NodeType: "generate_number",
	}
}

// ImageClassificationNode corresponds to the JSON schema definition 'ImageClassificationNode'.
// Node for image classification. Base type for all nodes in the graph.
type ImageClassificationNode struct {
	Input       string          `json:"input"`
	ModelSource ModelSourceBase `json:"model_source"`
	Name        string          `json:"name"`
	NodeType    string          `json:"node_type"`
	Output      string          `json:"output"`
}

// isNode implements the Node interface.
func (s *ImageClassificationNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ImageClassificationNode to handle interface fields
func (s *ImageClassificationNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ImageClassificationNode

	intermediate := struct {
		Alias
		ModelSource json.RawMessage `json:"model_source"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ImageClassificationNode: %w", err)
	}

	// Copy the standard fields
	*s = ImageClassificationNode(intermediate.Alias)

	// Unmarshal the ModelSource field (ModelSourceBase interface)
	if len(intermediate.ModelSource) > 0 {
		var item ModelSourceBase
		if err := UnmarshalJSONModelSourceBase(intermediate.ModelSource, &item); err != nil {
			return fmt.Errorf("error unmarshaling ModelSource: %w", err)
		}
		s.ModelSource = item
	}

	return nil
}

// NewImageClassificationNode creates a new instance of ImageClassificationNode
func NewImageClassificationNode(name string, input string, output string) *ImageClassificationNode {
	return &ImageClassificationNode{
		Name:     name,
		Input:    input,
		Output:   output,
		NodeType: "image_classification",
	}
}

// SetModelSource sets the ModelSource field for ImageClassificationNode
func (s *ImageClassificationNode) SetModelSource(modelsource ModelSourceBase) {
	s.ModelSource = modelsource
}

// ImageObjectDetectionNode corresponds to the JSON schema definition 'ImageObjectDetectionNode'.
// Node for image object detection. Base type for all nodes in the graph.
type ImageObjectDetectionNode struct {
	Input              string          `json:"input"`
	ModelSource        ModelSourceBase `json:"model_source"`
	Name               string          `json:"name"`
	NodeType           string          `json:"node_type"`
	Output             string          `json:"output"`
	ScaleBoundingBoxes bool            `json:"scale_bounding_boxes"`
}

// isNode implements the Node interface.
func (s *ImageObjectDetectionNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ImageObjectDetectionNode to handle interface fields
func (s *ImageObjectDetectionNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ImageObjectDetectionNode

	intermediate := struct {
		Alias
		ModelSource json.RawMessage `json:"model_source"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ImageObjectDetectionNode: %w", err)
	}

	// Copy the standard fields
	*s = ImageObjectDetectionNode(intermediate.Alias)

	// Unmarshal the ModelSource field (ModelSourceBase interface)
	if len(intermediate.ModelSource) > 0 {
		var item ModelSourceBase
		if err := UnmarshalJSONModelSourceBase(intermediate.ModelSource, &item); err != nil {
			return fmt.Errorf("error unmarshaling ModelSource: %w", err)
		}
		s.ModelSource = item
	}

	return nil
}

// NewImageObjectDetectionNode creates a new instance of ImageObjectDetectionNode
func NewImageObjectDetectionNode(name string, input string, output string, scaleboundingboxes bool) *ImageObjectDetectionNode {
	return &ImageObjectDetectionNode{
		Name:               name,
		Input:              input,
		Output:             output,
		ScaleBoundingBoxes: scaleboundingboxes,
		NodeType:           "image_object_detection",
	}
}

// SetModelSource sets the ModelSource field for ImageObjectDetectionNode
func (s *ImageObjectDetectionNode) SetModelSource(modelsource ModelSourceBase) {
	s.ModelSource = modelsource
}

// ImageOcrNode corresponds to the JSON schema definition 'ImageOcrNode'.
// Node for image OCR. Base type for all nodes in the graph.
type ImageOcrNode struct {
	Input       string          `json:"input"`
	ModelSource ModelSourceBase `json:"model_source"`
	Name        string          `json:"name"`
	NodeType    string          `json:"node_type"`
	Output      string          `json:"output"`
}

// isNode implements the Node interface.
func (s *ImageOcrNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ImageOcrNode to handle interface fields
func (s *ImageOcrNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ImageOcrNode

	intermediate := struct {
		Alias
		ModelSource json.RawMessage `json:"model_source"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ImageOcrNode: %w", err)
	}

	// Copy the standard fields
	*s = ImageOcrNode(intermediate.Alias)

	// Unmarshal the ModelSource field (ModelSourceBase interface)
	if len(intermediate.ModelSource) > 0 {
		var item ModelSourceBase
		if err := UnmarshalJSONModelSourceBase(intermediate.ModelSource, &item); err != nil {
			return fmt.Errorf("error unmarshaling ModelSource: %w", err)
		}
		s.ModelSource = item
	}

	return nil
}

// NewImageOcrNode creates a new instance of ImageOcrNode
func NewImageOcrNode(name string, input string, output string) *ImageOcrNode {
	return &ImageOcrNode{
		Name:     name,
		Input:    input,
		Output:   output,
		NodeType: "image_ocr",
	}
}

// SetModelSource sets the ModelSource field for ImageOcrNode
func (s *ImageOcrNode) SetModelSource(modelsource ModelSourceBase) {
	s.ModelSource = modelsource
}

// ImagePatchesNode corresponds to the JSON schema definition 'ImagePatchesNode'.
// Node that extracts patches from an image based on bounding boxes. Base type for all nodes in the graph.
type ImagePatchesNode struct {
	InputBatchMap          string `json:"input_batch_map"`
	InputBoxes             string `json:"input_boxes"`
	InputImage             string `json:"input_image"`
	InputMaximumIterations string `json:"input_maximum_iterations"`
	InputTargetSize        string `json:"input_target_size"`
	Name                   string `json:"name"`
	NodeType               string `json:"node_type"`
	Output                 string `json:"output"`
}

// isNode implements the Node interface.
func (s *ImagePatchesNode) isNode() {}

// NewImagePatchesNode creates a new instance of ImagePatchesNode
func NewImagePatchesNode(name string, inputimage string, inputboxes string, inputbatchmap string, inputtargetsize string, inputmaximumiterations string, output string) *ImagePatchesNode {
	return &ImagePatchesNode{
		Name:                   name,
		InputImage:             inputimage,
		InputBoxes:             inputboxes,
		InputBatchMap:          inputbatchmap,
		InputTargetSize:        inputtargetsize,
		InputMaximumIterations: inputmaximumiterations,
		Output:                 output,
		NodeType:               "image_patches",
	}
}

// ImageResizeNode corresponds to the JSON schema definition 'ImageResizeNode'.
// Node that resizes an image. Base type for all nodes in the graph.
type ImageResizeNode struct {
	InputImage string `json:"input_image"`
	InputSize  string `json:"input_size"`
	Name       string `json:"name"`
	NodeType   string `json:"node_type"`
	Output     string `json:"output"`
}

// isNode implements the Node interface.
func (s *ImageResizeNode) isNode() {}

// NewImageResizeNode creates a new instance of ImageResizeNode
func NewImageResizeNode(name string, inputsize string, inputimage string, output string) *ImageResizeNode {
	return &ImageResizeNode{
		Name:       name,
		InputSize:  inputsize,
		InputImage: inputimage,
		Output:     output,
		NodeType:   "image_resize",
	}
}

// ModelSourceFromNetworkExperimentId corresponds to the JSON schema definition 'ModelSourceFromNetworkExperimentId'.
// Model source specified by a network experiment ID. Base type for the source of the model.
type ModelSourceFromNetworkExperimentId struct {
	NetworkExperimentId string `json:"network_experiment_id"`
	SourceType          string `json:"source_type"`
}

// isModelSourceBase implements the ModelSourceBase interface.
func (s *ModelSourceFromNetworkExperimentId) isModelSourceBase() {}

// NewModelSourceFromNetworkExperimentId creates a new instance of ModelSourceFromNetworkExperimentId
func NewModelSourceFromNetworkExperimentId(networkexperimentid string) *ModelSourceFromNetworkExperimentId {
	return &ModelSourceFromNetworkExperimentId{
		NetworkExperimentId: networkexperimentid,
		SourceType:          "network_experiment_id",
	}
}

// ModelSourceFromNetworkId corresponds to the JSON schema definition 'ModelSourceFromNetworkId'.
// Model source specified by a network ID. Base type for the source of the model.
type ModelSourceFromNetworkId struct {
	NetworkId  string `json:"network_id"`
	SourceType string `json:"source_type"`
}

// isModelSourceBase implements the ModelSourceBase interface.
func (s *ModelSourceFromNetworkId) isModelSourceBase() {}

// NewModelSourceFromNetworkId creates a new instance of ModelSourceFromNetworkId
func NewModelSourceFromNetworkId(networkid string) *ModelSourceFromNetworkId {
	return &ModelSourceFromNetworkId{
		NetworkId:  networkid,
		SourceType: "network_id",
	}
}

// VirtualCameraNode corresponds to the JSON schema definition 'VirtualCameraNode'.
// Node representing a virtual camera source. Base type for all nodes in the graph.
type VirtualCameraNode struct {
	Name     string `json:"name"`
	NodeType string `json:"node_type"`
	Output   string `json:"output"`
	Path     string `json:"path"`
}

// isNode implements the Node interface.
func (s *VirtualCameraNode) isNode() {}

// NewVirtualCameraNode creates a new instance of VirtualCameraNode
func NewVirtualCameraNode(name string, output string, path string) *VirtualCameraNode {
	return &VirtualCameraNode{
		Name:     name,
		Output:   output,
		Path:     path,
		NodeType: "virtual_camera",
	}
}

// ConstTensorDataBase defines the interface for discriminated union based on data_type.
type ConstTensorDataBase interface {
	isConstTensorDataBase() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for ConstTensorDataBase, handling polymorphism.
func UnmarshalJSONConstTensorDataBase(data []byte, c *ConstTensorDataBase) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderConstTensorDataBase struct {
		Type string `json:"data_type"`
	}
	if err := json.Unmarshal(data, &typeFinderConstTensorDataBase); err != nil {
		return fmt.Errorf("error finding discriminator field 'data_type' for ConstTensorDataBase: %w", err)
	}

	switch typeFinderConstTensorDataBase.Type {
	case "float64":
		var concrete ConstTensorFloat64Data
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorFloat64Data: %w", err)
		}
		*c = &concrete
		return nil
	case "int64":
		var concrete ConstTensorInt64Data
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorInt64Data: %w", err)
		}
		*c = &concrete
		return nil
	case "uint64":
		var concrete ConstTensorUint64Data
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorUint64Data: %w", err)
		}
		*c = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface ConstTensorDataBase", typeFinderConstTensorDataBase.Type)
	}
}

// ConstTensorDataBaseUnmarshaler is an implementation of json.Unmarshaler for ConstTensorDataBase interface
type ConstTensorDataBaseUnmarshaler struct {
	Target *ConstTensorDataBase
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u ConstTensorDataBaseUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONConstTensorDataBase(data, u.Target)
}

// ModelSourceBase defines the interface for discriminated union based on source_type.
type ModelSourceBase interface {
	isModelSourceBase() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for ModelSourceBase, handling polymorphism.
func UnmarshalJSONModelSourceBase(data []byte, m *ModelSourceBase) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderModelSourceBase struct {
		Type string `json:"source_type"`
	}
	if err := json.Unmarshal(data, &typeFinderModelSourceBase); err != nil {
		return fmt.Errorf("error finding discriminator field 'source_type' for ModelSourceBase: %w", err)
	}

	switch typeFinderModelSourceBase.Type {
	case "network_experiment_id":
		var concrete ModelSourceFromNetworkExperimentId
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ModelSourceFromNetworkExperimentId: %w", err)
		}
		*m = &concrete
		return nil
	case "network_id":
		var concrete ModelSourceFromNetworkId
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ModelSourceFromNetworkId: %w", err)
		}
		*m = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface ModelSourceBase", typeFinderModelSourceBase.Type)
	}
}

// ModelSourceBaseUnmarshaler is an implementation of json.Unmarshaler for ModelSourceBase interface
type ModelSourceBaseUnmarshaler struct {
	Target *ModelSourceBase
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u ModelSourceBaseUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONModelSourceBase(data, u.Target)
}

// Node defines the interface for discriminated union based on node_type.
type Node interface {
	isNode() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for Node, handling polymorphism.
func UnmarshalJSONNode(data []byte, n *Node) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderNode struct {
		Type string `json:"node_type"`
	}
	if err := json.Unmarshal(data, &typeFinderNode); err != nil {
		return fmt.Errorf("error finding discriminator field 'node_type' for Node: %w", err)
	}

	switch typeFinderNode.Type {
	case "add_numbers":
		var concrete AddNumbersNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into AddNumbersNode: %w", err)
		}
		*n = &concrete
		return nil
	case "bounding_box_filter":
		var concrete BoundingBoxFilterNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into BoundingBoxFilterNode: %w", err)
		}
		*n = &concrete
		return nil
	case "const_tensor":
		var concrete ConstTensorNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorNode: %w", err)
		}
		*n = &concrete
		return nil
	case "generate_number":
		var concrete GenerateNumberNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into GenerateNumberNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_classification":
		var concrete ImageClassificationNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImageClassificationNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_object_detection":
		var concrete ImageObjectDetectionNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImageObjectDetectionNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_ocr":
		var concrete ImageOcrNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImageOcrNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_patches":
		var concrete ImagePatchesNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImagePatchesNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_resize":
		var concrete ImageResizeNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImageResizeNode: %w", err)
		}
		*n = &concrete
		return nil
	case "virtual_camera":
		var concrete VirtualCameraNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into VirtualCameraNode: %w", err)
		}
		*n = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface Node", typeFinderNode.Type)
	}
}

// NodeUnmarshaler is an implementation of json.Unmarshaler for Node interface
type NodeUnmarshaler struct {
	Target *Node
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u NodeUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONNode(data, u.Target)
}

// InferenceGraphRecipe corresponds to the top-level JSON schema object.
type InferenceGraphRecipe struct {
	CreatedAt int64  `json:"created_at"`
	LicenseId string `json:"license_id"`
	Nodes     []Node `json:"nodes"`
}

// UnmarshalJSON implements custom unmarshaling for InferenceGraphRecipe to handle interface fields
func (s *InferenceGraphRecipe) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias InferenceGraphRecipe

	intermediate := struct {
		Alias
		Nodes []json.RawMessage `json:"nodes"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling InferenceGraphRecipe: %w", err)
	}

	// Copy the standard fields
	*s = InferenceGraphRecipe(intermediate.Alias)

	// Unmarshal the Nodes field (slice of Node interfaces)
	if intermediate.Nodes != nil {
		s.Nodes = make([]Node, len(intermediate.Nodes))
		for i, raw := range intermediate.Nodes {
			var item Node
			if err := UnmarshalJSONNode(raw, &item); err != nil {
				return fmt.Errorf("error unmarshaling Nodes[%d]: %w", i, err)
			}
			s.Nodes[i] = item
		}
	}

	return nil
}
