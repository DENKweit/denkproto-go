// Code generated by generate_go_code.go; DO NOT EDIT.
// Based on schema: ../inference_graph_recipe.schema.json

package inference_graph_recipe

import (
	"encoding/json"
	"fmt"
)

// BoundingBoxFilterNode corresponds to the JSON schema definition 'BoundingBoxFilterNode'.
// Node that filters bounding boxes based on confidence and IoU thresholds. Base type for all nodes in the graph.
type BoundingBoxFilterNode struct {
	InputBoundingBoxes  string          `json:"input_bounding_boxes"`
	InputIouThreshold   ThresholdSource `json:"input_iou_threshold"`
	InputScoreThreshold ThresholdSource `json:"input_score_threshold"`
	Name                string          `json:"name"`
	NodeType            string          `json:"node_type"`
	OutputPortName      string          `json:"output_port_name"`
}

// isNode implements the Node interface.
func (s *BoundingBoxFilterNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for BoundingBoxFilterNode to handle interface fields
func (s *BoundingBoxFilterNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias BoundingBoxFilterNode

	intermediate := struct {
		Alias
		InputIouThreshold   json.RawMessage `json:"input_iou_threshold"`
		InputScoreThreshold json.RawMessage `json:"input_score_threshold"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling BoundingBoxFilterNode: %w", err)
	}

	// Copy the standard fields
	*s = BoundingBoxFilterNode(intermediate.Alias)

	// Unmarshal the InputIouThreshold field (ThresholdSource interface)
	if len(intermediate.InputIouThreshold) > 0 {
		var item ThresholdSource
		if err := UnmarshalJSONThresholdSource(intermediate.InputIouThreshold, &item); err != nil {
			return fmt.Errorf("error unmarshaling InputIouThreshold: %w", err)
		}
		s.InputIouThreshold = item
	}

	// Unmarshal the InputScoreThreshold field (ThresholdSource interface)
	if len(intermediate.InputScoreThreshold) > 0 {
		var item ThresholdSource
		if err := UnmarshalJSONThresholdSource(intermediate.InputScoreThreshold, &item); err != nil {
			return fmt.Errorf("error unmarshaling InputScoreThreshold: %w", err)
		}
		s.InputScoreThreshold = item
	}

	return nil
}

// NewBoundingBoxFilterNode creates a new instance of BoundingBoxFilterNode
func NewBoundingBoxFilterNode(name string, inputboundingboxes string, outputportname string) *BoundingBoxFilterNode {
	return &BoundingBoxFilterNode{
		Name:               name,
		InputBoundingBoxes: inputboundingboxes,
		OutputPortName:     outputportname,
		NodeType:           "bounding_box_filter",
	}
}

// SetInputIouThreshold sets the InputIouThreshold field for BoundingBoxFilterNode
func (s *BoundingBoxFilterNode) SetInputIouThreshold(inputiouthreshold ThresholdSource) {
	s.InputIouThreshold = inputiouthreshold
}

// SetInputScoreThreshold sets the InputScoreThreshold field for BoundingBoxFilterNode
func (s *BoundingBoxFilterNode) SetInputScoreThreshold(inputscorethreshold ThresholdSource) {
	s.InputScoreThreshold = inputscorethreshold
}

// ClassificationNode corresponds to the JSON schema definition 'ClassificationNode'.
// Node for image classification. Base type for all nodes in the graph.
type ClassificationNode struct {
	InputImage     string          `json:"inputImage"`
	ModelSource    ModelSourceBase `json:"model_source"`
	Name           string          `json:"name"`
	NodeType       string          `json:"node_type"`
	OutputPortName string          `json:"output_port_name"`
}

// isNode implements the Node interface.
func (s *ClassificationNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ClassificationNode to handle interface fields
func (s *ClassificationNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ClassificationNode

	intermediate := struct {
		Alias
		ModelSource json.RawMessage `json:"model_source"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ClassificationNode: %w", err)
	}

	// Copy the standard fields
	*s = ClassificationNode(intermediate.Alias)

	// Unmarshal the ModelSource field (ModelSourceBase interface)
	if len(intermediate.ModelSource) > 0 {
		var item ModelSourceBase
		if err := UnmarshalJSONModelSourceBase(intermediate.ModelSource, &item); err != nil {
			return fmt.Errorf("error unmarshaling ModelSource: %w", err)
		}
		s.ModelSource = item
	}

	return nil
}

// NewClassificationNode creates a new instance of ClassificationNode
func NewClassificationNode(name string, inputimage string, outputportname string) *ClassificationNode {
	return &ClassificationNode{
		Name:           name,
		InputImage:     inputimage,
		OutputPortName: outputportname,
		NodeType:       "image_classification",
	}
}

// SetModelSource sets the ModelSource field for ClassificationNode
func (s *ClassificationNode) SetModelSource(modelsource ModelSourceBase) {
	s.ModelSource = modelsource
}

// ConstTensorFloat64Data corresponds to the JSON schema definition 'ConstTensorFloat64Data'.
// Constant tensor data of type float64. Base type for constant tensor data.
type ConstTensorFloat64Data struct {
	Data     []float64 `json:"data"`
	DataType string    `json:"data_type"`
}

// isConstTensorDataBase implements the ConstTensorDataBase interface.
func (s *ConstTensorFloat64Data) isConstTensorDataBase() {}

// NewConstTensorFloat64Data creates a new instance of ConstTensorFloat64Data
func NewConstTensorFloat64Data(data []float64) *ConstTensorFloat64Data {
	return &ConstTensorFloat64Data{
		Data:     data,
		DataType: "float64",
	}
}

// ConstTensorInt64Data corresponds to the JSON schema definition 'ConstTensorInt64Data'.
// Constant tensor data of type int64. Base type for constant tensor data.
type ConstTensorInt64Data struct {
	Data     []int64 `json:"data"`
	DataType string  `json:"data_type"`
}

// isConstTensorDataBase implements the ConstTensorDataBase interface.
func (s *ConstTensorInt64Data) isConstTensorDataBase() {}

// NewConstTensorInt64Data creates a new instance of ConstTensorInt64Data
func NewConstTensorInt64Data(data []int64) *ConstTensorInt64Data {
	return &ConstTensorInt64Data{
		Data:     data,
		DataType: "int64",
	}
}

// ConstTensorNode corresponds to the JSON schema definition 'ConstTensorNode'.
// Node representing a constant tensor. Base type for all nodes in the graph.
type ConstTensorNode struct {
	Data           ConstTensorDataBase `json:"data"`
	Name           string              `json:"name"`
	NodeType       string              `json:"node_type"`
	OutputPortName string              `json:"output_port_name"`
	Shape          []int64             `json:"shape"`
}

// isNode implements the Node interface.
func (s *ConstTensorNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ConstTensorNode to handle interface fields
func (s *ConstTensorNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ConstTensorNode

	intermediate := struct {
		Alias
		Data json.RawMessage `json:"data"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ConstTensorNode: %w", err)
	}

	// Copy the standard fields
	*s = ConstTensorNode(intermediate.Alias)

	// Unmarshal the Data field (ConstTensorDataBase interface)
	if len(intermediate.Data) > 0 {
		var item ConstTensorDataBase
		if err := UnmarshalJSONConstTensorDataBase(intermediate.Data, &item); err != nil {
			return fmt.Errorf("error unmarshaling Data: %w", err)
		}
		s.Data = item
	}

	return nil
}

// NewConstTensorNode creates a new instance of ConstTensorNode
func NewConstTensorNode(name string, shape []int64, outputportname string) *ConstTensorNode {
	return &ConstTensorNode{
		Name:           name,
		Shape:          shape,
		OutputPortName: outputportname,
		NodeType:       "const_tensor",
	}
}

// SetData sets the Data field for ConstTensorNode
func (s *ConstTensorNode) SetData(data ConstTensorDataBase) {
	s.Data = data
}

// ConstTensorUint64Data corresponds to the JSON schema definition 'ConstTensorUint64Data'.
// Constant tensor data of type uint64. Base type for constant tensor data.
type ConstTensorUint64Data struct {
	Data     []int64 `json:"data"`
	DataType string  `json:"data_type"`
}

// isConstTensorDataBase implements the ConstTensorDataBase interface.
func (s *ConstTensorUint64Data) isConstTensorDataBase() {}

// NewConstTensorUint64Data creates a new instance of ConstTensorUint64Data
func NewConstTensorUint64Data(data []int64) *ConstTensorUint64Data {
	return &ConstTensorUint64Data{
		Data:     data,
		DataType: "uint64",
	}
}

// ImagePatchesNode corresponds to the JSON schema definition 'ImagePatchesNode'.
// Node that extracts patches from an image based on bounding boxes. Base type for all nodes in the graph.
type ImagePatchesNode struct {
	InputBoundingBoxes     string                   `json:"input_bounding_boxes"`
	InputImage             string                   `json:"input_image"`
	InputMaximumIterations MaxIterationsCountSource `json:"input_maximum_iterations"`
	InputTargetSize        TargetSizeSource         `json:"input_target_size"`
	Name                   string                   `json:"name"`
	NodeType               string                   `json:"node_type"`
	OutputPortName         string                   `json:"output_port_name"`
}

// isNode implements the Node interface.
func (s *ImagePatchesNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ImagePatchesNode to handle interface fields
func (s *ImagePatchesNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ImagePatchesNode

	intermediate := struct {
		Alias
		InputMaximumIterations json.RawMessage `json:"input_maximum_iterations"`
		InputTargetSize        json.RawMessage `json:"input_target_size"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ImagePatchesNode: %w", err)
	}

	// Copy the standard fields
	*s = ImagePatchesNode(intermediate.Alias)

	// Unmarshal the InputMaximumIterations field (MaxIterationsCountSource interface)
	if len(intermediate.InputMaximumIterations) > 0 {
		var item MaxIterationsCountSource
		if err := UnmarshalJSONMaxIterationsCountSource(intermediate.InputMaximumIterations, &item); err != nil {
			return fmt.Errorf("error unmarshaling InputMaximumIterations: %w", err)
		}
		s.InputMaximumIterations = item
	}

	// Unmarshal the InputTargetSize field (TargetSizeSource interface)
	if len(intermediate.InputTargetSize) > 0 {
		var item TargetSizeSource
		if err := UnmarshalJSONTargetSizeSource(intermediate.InputTargetSize, &item); err != nil {
			return fmt.Errorf("error unmarshaling InputTargetSize: %w", err)
		}
		s.InputTargetSize = item
	}

	return nil
}

// NewImagePatchesNode creates a new instance of ImagePatchesNode
func NewImagePatchesNode(name string, inputimage string, inputboundingboxes string, outputportname string) *ImagePatchesNode {
	return &ImagePatchesNode{
		Name:               name,
		InputImage:         inputimage,
		InputBoundingBoxes: inputboundingboxes,
		OutputPortName:     outputportname,
		NodeType:           "image_patches",
	}
}

// SetInputMaximumIterations sets the InputMaximumIterations field for ImagePatchesNode
func (s *ImagePatchesNode) SetInputMaximumIterations(inputmaximumiterations MaxIterationsCountSource) {
	s.InputMaximumIterations = inputmaximumiterations
}

// SetInputTargetSize sets the InputTargetSize field for ImagePatchesNode
func (s *ImagePatchesNode) SetInputTargetSize(inputtargetsize TargetSizeSource) {
	s.InputTargetSize = inputtargetsize
}

// ImageResizeNode corresponds to the JSON schema definition 'ImageResizeNode'.
// Node that resizes an image. Base type for all nodes in the graph.
type ImageResizeNode struct {
	InputImage     string `json:"input_image"`
	InputSize      string `json:"input_size"`
	Name           string `json:"name"`
	NodeType       string `json:"node_type"`
	OutputPortName string `json:"output_port_name"`
}

// isNode implements the Node interface.
func (s *ImageResizeNode) isNode() {}

// NewImageResizeNode creates a new instance of ImageResizeNode
func NewImageResizeNode(name string, inputsize string, inputimage string, outputportname string) *ImageResizeNode {
	return &ImageResizeNode{
		Name:           name,
		InputSize:      inputsize,
		InputImage:     inputimage,
		OutputPortName: outputportname,
		NodeType:       "image_resize",
	}
}

// ImageSize corresponds to the JSON schema definition 'ImageSize'.
// Represents image dimensions.
type ImageSize struct {
	Height int64 `json:"height"`
	Width  int64 `json:"width"`
}

// NewImageSize creates a new instance of ImageSize
func NewImageSize(height int64, width int64) *ImageSize {
	return &ImageSize{
		Height: height,
		Width:  width,
	}
}

// MaxIterationsCountSourceTopicOption corresponds to the JSON schema definition 'inline-MaxIterationsCountSourceTopicOption'.
type MaxIterationsCountSourceTopicOption struct {
	SourceType string `json:"source_type"`
	Topic      string `json:"topic"`
}

// isMaxIterationsCountSource implements the MaxIterationsCountSource interface.
func (s *MaxIterationsCountSourceTopicOption) isMaxIterationsCountSource() {}

// NewMaxIterationsCountSourceTopicOption creates a new instance of MaxIterationsCountSourceTopicOption
func NewMaxIterationsCountSourceTopicOption(topic string) *MaxIterationsCountSourceTopicOption {
	return &MaxIterationsCountSourceTopicOption{
		Topic:      topic,
		SourceType: "topic",
	}
}

// MaxIterationsCountSourceValueOption corresponds to the JSON schema definition 'inline-MaxIterationsCountSourceValueOption'.
type MaxIterationsCountSourceValueOption struct {
	SourceType string `json:"source_type"`
	Value      int64  `json:"value"`
}

// isMaxIterationsCountSource implements the MaxIterationsCountSource interface.
func (s *MaxIterationsCountSourceValueOption) isMaxIterationsCountSource() {}

// NewMaxIterationsCountSourceValueOption creates a new instance of MaxIterationsCountSourceValueOption
func NewMaxIterationsCountSourceValueOption(value int64) *MaxIterationsCountSourceValueOption {
	return &MaxIterationsCountSourceValueOption{
		Value:      value,
		SourceType: "value",
	}
}

// ModelSourceFromNetworkExperimentId corresponds to the JSON schema definition 'ModelSourceFromNetworkExperimentId'.
// Model source specified by a network experiment ID. Base type for the source of the model.
type ModelSourceFromNetworkExperimentId struct {
	NetworkExperimentId string `json:"network_experiment_id"`
	SourceType          string `json:"source_type"`
}

// isModelSourceBase implements the ModelSourceBase interface.
func (s *ModelSourceFromNetworkExperimentId) isModelSourceBase() {}

// NewModelSourceFromNetworkExperimentId creates a new instance of ModelSourceFromNetworkExperimentId
func NewModelSourceFromNetworkExperimentId(networkexperimentid string) *ModelSourceFromNetworkExperimentId {
	return &ModelSourceFromNetworkExperimentId{
		NetworkExperimentId: networkexperimentid,
		SourceType:          "network_experiment_id",
	}
}

// ModelSourceFromNetworkId corresponds to the JSON schema definition 'ModelSourceFromNetworkId'.
// Model source specified by a network ID. Base type for the source of the model.
type ModelSourceFromNetworkId struct {
	NetworkId  string `json:"network_id"`
	SourceType string `json:"source_type"`
}

// isModelSourceBase implements the ModelSourceBase interface.
func (s *ModelSourceFromNetworkId) isModelSourceBase() {}

// NewModelSourceFromNetworkId creates a new instance of ModelSourceFromNetworkId
func NewModelSourceFromNetworkId(networkid string) *ModelSourceFromNetworkId {
	return &ModelSourceFromNetworkId{
		NetworkId:  networkid,
		SourceType: "network_id",
	}
}

// ObjectDetectionNode corresponds to the JSON schema definition 'ObjectDetectionNode'.
// Node for image object detection. Base type for all nodes in the graph.
type ObjectDetectionNode struct {
	InputImage         string          `json:"input_image"`
	ModelSource        ModelSourceBase `json:"model_source"`
	Name               string          `json:"name"`
	NodeType           string          `json:"node_type"`
	OutputPortName     string          `json:"output_port_name"`
	ScaleBoundingBoxes bool            `json:"scale_bounding_boxes"`
}

// isNode implements the Node interface.
func (s *ObjectDetectionNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for ObjectDetectionNode to handle interface fields
func (s *ObjectDetectionNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias ObjectDetectionNode

	intermediate := struct {
		Alias
		ModelSource json.RawMessage `json:"model_source"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling ObjectDetectionNode: %w", err)
	}

	// Copy the standard fields
	*s = ObjectDetectionNode(intermediate.Alias)

	// Unmarshal the ModelSource field (ModelSourceBase interface)
	if len(intermediate.ModelSource) > 0 {
		var item ModelSourceBase
		if err := UnmarshalJSONModelSourceBase(intermediate.ModelSource, &item); err != nil {
			return fmt.Errorf("error unmarshaling ModelSource: %w", err)
		}
		s.ModelSource = item
	}

	return nil
}

// NewObjectDetectionNode creates a new instance of ObjectDetectionNode
func NewObjectDetectionNode(name string, inputimage string, outputportname string, scaleboundingboxes bool) *ObjectDetectionNode {
	return &ObjectDetectionNode{
		Name:               name,
		InputImage:         inputimage,
		OutputPortName:     outputportname,
		ScaleBoundingBoxes: scaleboundingboxes,
		NodeType:           "image_object_detection",
	}
}

// SetModelSource sets the ModelSource field for ObjectDetectionNode
func (s *ObjectDetectionNode) SetModelSource(modelsource ModelSourceBase) {
	s.ModelSource = modelsource
}

// OcrNode corresponds to the JSON schema definition 'OcrNode'.
// Node for image OCR. Base type for all nodes in the graph.
type OcrNode struct {
	InputImage     string          `json:"input_image"`
	ModelSource    ModelSourceBase `json:"model_source"`
	Name           string          `json:"name"`
	NodeType       string          `json:"node_type"`
	OutputPortName string          `json:"output_port_name"`
}

// isNode implements the Node interface.
func (s *OcrNode) isNode() {}

// UnmarshalJSON implements custom unmarshaling for OcrNode to handle interface fields
func (s *OcrNode) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias OcrNode

	intermediate := struct {
		Alias
		ModelSource json.RawMessage `json:"model_source"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling OcrNode: %w", err)
	}

	// Copy the standard fields
	*s = OcrNode(intermediate.Alias)

	// Unmarshal the ModelSource field (ModelSourceBase interface)
	if len(intermediate.ModelSource) > 0 {
		var item ModelSourceBase
		if err := UnmarshalJSONModelSourceBase(intermediate.ModelSource, &item); err != nil {
			return fmt.Errorf("error unmarshaling ModelSource: %w", err)
		}
		s.ModelSource = item
	}

	return nil
}

// NewOcrNode creates a new instance of OcrNode
func NewOcrNode(name string, inputimage string, outputportname string) *OcrNode {
	return &OcrNode{
		Name:           name,
		InputImage:     inputimage,
		OutputPortName: outputportname,
		NodeType:       "image_ocr",
	}
}

// SetModelSource sets the ModelSource field for OcrNode
func (s *OcrNode) SetModelSource(modelsource ModelSourceBase) {
	s.ModelSource = modelsource
}

// TargetSizeSourceImageSizeOption corresponds to the JSON schema definition 'inline-TargetSizeSourceImageSizeOption'.
type TargetSizeSourceImageSizeOption struct {
	Size       *ImageSize `json:"size"`
	SourceType string     `json:"source_type"`
}

// isTargetSizeSource implements the TargetSizeSource interface.
func (s *TargetSizeSourceImageSizeOption) isTargetSizeSource() {}

// NewTargetSizeSourceImageSizeOption creates a new instance of TargetSizeSourceImageSizeOption
func NewTargetSizeSourceImageSizeOption(size *ImageSize) *TargetSizeSourceImageSizeOption {
	return &TargetSizeSourceImageSizeOption{
		Size:       size,
		SourceType: "image_size",
	}
}

// TargetSizeSourceTopicOption corresponds to the JSON schema definition 'inline-TargetSizeSourceTopicOption'.
type TargetSizeSourceTopicOption struct {
	SourceType string `json:"source_type"`
	Topic      string `json:"topic"`
}

// isTargetSizeSource implements the TargetSizeSource interface.
func (s *TargetSizeSourceTopicOption) isTargetSizeSource() {}

// NewTargetSizeSourceTopicOption creates a new instance of TargetSizeSourceTopicOption
func NewTargetSizeSourceTopicOption(topic string) *TargetSizeSourceTopicOption {
	return &TargetSizeSourceTopicOption{
		Topic:      topic,
		SourceType: "topic",
	}
}

// ThresholdSourceTopicOption corresponds to the JSON schema definition 'inline-ThresholdSourceTopicOption'.
type ThresholdSourceTopicOption struct {
	SourceType string `json:"source_type"`
	Topic      string `json:"topic"`
}

// isThresholdSource implements the ThresholdSource interface.
func (s *ThresholdSourceTopicOption) isThresholdSource() {}

// NewThresholdSourceTopicOption creates a new instance of ThresholdSourceTopicOption
func NewThresholdSourceTopicOption(topic string) *ThresholdSourceTopicOption {
	return &ThresholdSourceTopicOption{
		Topic:      topic,
		SourceType: "topic",
	}
}

// ThresholdSourceValueOption corresponds to the JSON schema definition 'inline-ThresholdSourceValueOption'.
type ThresholdSourceValueOption struct {
	SourceType string  `json:"source_type"`
	Value      float64 `json:"value"`
}

// isThresholdSource implements the ThresholdSource interface.
func (s *ThresholdSourceValueOption) isThresholdSource() {}

// NewThresholdSourceValueOption creates a new instance of ThresholdSourceValueOption
func NewThresholdSourceValueOption(value float64) *ThresholdSourceValueOption {
	return &ThresholdSourceValueOption{
		Value:      value,
		SourceType: "value",
	}
}

// VirtualCameraNode corresponds to the JSON schema definition 'VirtualCameraNode'.
// Node representing a virtual camera source. Base type for all nodes in the graph.
type VirtualCameraNode struct {
	Name           string `json:"name"`
	NodeType       string `json:"node_type"`
	OutputPortName string `json:"output_port_name"`
	Path           string `json:"path"`
}

// isNode implements the Node interface.
func (s *VirtualCameraNode) isNode() {}

// NewVirtualCameraNode creates a new instance of VirtualCameraNode
func NewVirtualCameraNode(name string, path string, outputportname string) *VirtualCameraNode {
	return &VirtualCameraNode{
		Name:           name,
		Path:           path,
		OutputPortName: outputportname,
		NodeType:       "virtual_camera",
	}
}

// ConstTensorDataBase defines the interface for discriminated union based on data_type.
type ConstTensorDataBase interface {
	isConstTensorDataBase() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for ConstTensorDataBase, handling polymorphism.
func UnmarshalJSONConstTensorDataBase(data []byte, c *ConstTensorDataBase) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderConstTensorDataBase struct {
		Type string `json:"data_type"`
	}
	if err := json.Unmarshal(data, &typeFinderConstTensorDataBase); err != nil {
		return fmt.Errorf("error finding discriminator field 'data_type' for ConstTensorDataBase: %w", err)
	}

	switch typeFinderConstTensorDataBase.Type {
	case "float64":
		var concrete ConstTensorFloat64Data
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorFloat64Data: %w", err)
		}
		*c = &concrete
		return nil
	case "int64":
		var concrete ConstTensorInt64Data
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorInt64Data: %w", err)
		}
		*c = &concrete
		return nil
	case "uint64":
		var concrete ConstTensorUint64Data
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorUint64Data: %w", err)
		}
		*c = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface ConstTensorDataBase", typeFinderConstTensorDataBase.Type)
	}
}

// ConstTensorDataBaseUnmarshaler is an implementation of json.Unmarshaler for ConstTensorDataBase interface
type ConstTensorDataBaseUnmarshaler struct {
	Target *ConstTensorDataBase
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u ConstTensorDataBaseUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONConstTensorDataBase(data, u.Target)
}

// MaxIterationsCountSource defines the interface for discriminated union based on source_type.
type MaxIterationsCountSource interface {
	isMaxIterationsCountSource() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for MaxIterationsCountSource, handling polymorphism.
func UnmarshalJSONMaxIterationsCountSource(data []byte, m *MaxIterationsCountSource) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderMaxIterationsCountSource struct {
		Type string `json:"source_type"`
	}
	if err := json.Unmarshal(data, &typeFinderMaxIterationsCountSource); err != nil {
		return fmt.Errorf("error finding discriminator field 'source_type' for MaxIterationsCountSource: %w", err)
	}

	switch typeFinderMaxIterationsCountSource.Type {
	case "topic":
		var concrete MaxIterationsCountSourceTopicOption
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into MaxIterationsCountSourceTopicOption: %w", err)
		}
		*m = &concrete
		return nil
	case "value":
		var concrete MaxIterationsCountSourceValueOption
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into MaxIterationsCountSourceValueOption: %w", err)
		}
		*m = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface MaxIterationsCountSource", typeFinderMaxIterationsCountSource.Type)
	}
}

// MaxIterationsCountSourceUnmarshaler is an implementation of json.Unmarshaler for MaxIterationsCountSource interface
type MaxIterationsCountSourceUnmarshaler struct {
	Target *MaxIterationsCountSource
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u MaxIterationsCountSourceUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONMaxIterationsCountSource(data, u.Target)
}

// ModelSourceBase defines the interface for discriminated union based on source_type.
type ModelSourceBase interface {
	isModelSourceBase() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for ModelSourceBase, handling polymorphism.
func UnmarshalJSONModelSourceBase(data []byte, m *ModelSourceBase) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderModelSourceBase struct {
		Type string `json:"source_type"`
	}
	if err := json.Unmarshal(data, &typeFinderModelSourceBase); err != nil {
		return fmt.Errorf("error finding discriminator field 'source_type' for ModelSourceBase: %w", err)
	}

	switch typeFinderModelSourceBase.Type {
	case "network_experiment_id":
		var concrete ModelSourceFromNetworkExperimentId
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ModelSourceFromNetworkExperimentId: %w", err)
		}
		*m = &concrete
		return nil
	case "network_id":
		var concrete ModelSourceFromNetworkId
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ModelSourceFromNetworkId: %w", err)
		}
		*m = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface ModelSourceBase", typeFinderModelSourceBase.Type)
	}
}

// ModelSourceBaseUnmarshaler is an implementation of json.Unmarshaler for ModelSourceBase interface
type ModelSourceBaseUnmarshaler struct {
	Target *ModelSourceBase
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u ModelSourceBaseUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONModelSourceBase(data, u.Target)
}

// Node defines the interface for discriminated union based on node_type.
type Node interface {
	isNode() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for Node, handling polymorphism.
func UnmarshalJSONNode(data []byte, n *Node) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderNode struct {
		Type string `json:"node_type"`
	}
	if err := json.Unmarshal(data, &typeFinderNode); err != nil {
		return fmt.Errorf("error finding discriminator field 'node_type' for Node: %w", err)
	}

	switch typeFinderNode.Type {
	case "bounding_box_filter":
		var concrete BoundingBoxFilterNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into BoundingBoxFilterNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_classification":
		var concrete ClassificationNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ClassificationNode: %w", err)
		}
		*n = &concrete
		return nil
	case "const_tensor":
		var concrete ConstTensorNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ConstTensorNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_patches":
		var concrete ImagePatchesNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImagePatchesNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_resize":
		var concrete ImageResizeNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ImageResizeNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_object_detection":
		var concrete ObjectDetectionNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ObjectDetectionNode: %w", err)
		}
		*n = &concrete
		return nil
	case "image_ocr":
		var concrete OcrNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into OcrNode: %w", err)
		}
		*n = &concrete
		return nil
	case "virtual_camera":
		var concrete VirtualCameraNode
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into VirtualCameraNode: %w", err)
		}
		*n = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface Node", typeFinderNode.Type)
	}
}

// NodeUnmarshaler is an implementation of json.Unmarshaler for Node interface
type NodeUnmarshaler struct {
	Target *Node
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u NodeUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONNode(data, u.Target)
}

// TargetSizeSource defines the interface for discriminated union based on source_type.
type TargetSizeSource interface {
	isTargetSizeSource() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for TargetSizeSource, handling polymorphism.
func UnmarshalJSONTargetSizeSource(data []byte, t *TargetSizeSource) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderTargetSizeSource struct {
		Type string `json:"source_type"`
	}
	if err := json.Unmarshal(data, &typeFinderTargetSizeSource); err != nil {
		return fmt.Errorf("error finding discriminator field 'source_type' for TargetSizeSource: %w", err)
	}

	switch typeFinderTargetSizeSource.Type {
	case "image_size":
		var concrete TargetSizeSourceImageSizeOption
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into TargetSizeSourceImageSizeOption: %w", err)
		}
		*t = &concrete
		return nil
	case "topic":
		var concrete TargetSizeSourceTopicOption
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into TargetSizeSourceTopicOption: %w", err)
		}
		*t = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface TargetSizeSource", typeFinderTargetSizeSource.Type)
	}
}

// TargetSizeSourceUnmarshaler is an implementation of json.Unmarshaler for TargetSizeSource interface
type TargetSizeSourceUnmarshaler struct {
	Target *TargetSizeSource
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u TargetSizeSourceUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONTargetSizeSource(data, u.Target)
}

// ThresholdSource defines the interface for discriminated union based on source_type.
type ThresholdSource interface {
	isThresholdSource() // Dummy method for type assertion
}

// UnmarshalJSON implements the json.Unmarshaler interface for ThresholdSource, handling polymorphism.
func UnmarshalJSONThresholdSource(data []byte, t *ThresholdSource) error {
	// Determine the concrete type based on the discriminator field
	var typeFinderThresholdSource struct {
		Type string `json:"source_type"`
	}
	if err := json.Unmarshal(data, &typeFinderThresholdSource); err != nil {
		return fmt.Errorf("error finding discriminator field 'source_type' for ThresholdSource: %w", err)
	}

	switch typeFinderThresholdSource.Type {
	case "topic":
		var concrete ThresholdSourceTopicOption
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ThresholdSourceTopicOption: %w", err)
		}
		*t = &concrete
		return nil
	case "value":
		var concrete ThresholdSourceValueOption
		if err := json.Unmarshal(data, &concrete); err != nil {
			return fmt.Errorf("error unmarshaling into ThresholdSourceValueOption: %w", err)
		}
		*t = &concrete
		return nil
	default:
		return fmt.Errorf("unknown type '%s' for interface ThresholdSource", typeFinderThresholdSource.Type)
	}
}

// ThresholdSourceUnmarshaler is an implementation of json.Unmarshaler for ThresholdSource interface
type ThresholdSourceUnmarshaler struct {
	Target *ThresholdSource
}

// UnmarshalJSON for json.Unmarshaler implementation
func (u ThresholdSourceUnmarshaler) UnmarshalJSON(data []byte) error {
	return UnmarshalJSONThresholdSource(data, u.Target)
}

// InferenceGraphRecipe corresponds to the top-level JSON schema object.
type InferenceGraphRecipe struct {
	CreatedAt int64  `json:"created_at"`
	LicenseId string `json:"license_id"`
	Nodes     []Node `json:"nodes"`
}

// UnmarshalJSON implements custom unmarshaling for InferenceGraphRecipe to handle interface fields
func (s *InferenceGraphRecipe) UnmarshalJSON(data []byte) error {
	// Define an intermediate type with the same structure but using json.RawMessage for interface fields
	type Alias InferenceGraphRecipe

	intermediate := struct {
		Alias
		Nodes []json.RawMessage `json:"nodes"`
	}{}

	// Unmarshal into the intermediate struct
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return fmt.Errorf("error unmarshaling InferenceGraphRecipe: %w", err)
	}

	// Copy the standard fields
	*s = InferenceGraphRecipe(intermediate.Alias)

	// Unmarshal the Nodes field (slice of Node interfaces)
	if intermediate.Nodes != nil {
		s.Nodes = make([]Node, len(intermediate.Nodes))
		for i, raw := range intermediate.Nodes {
			var item Node
			if err := UnmarshalJSONNode(raw, &item); err != nil {
				return fmt.Errorf("error unmarshaling Nodes[%d]: %w", i, err)
			}
			s.Nodes[i] = item
		}
	}

	return nil
}
